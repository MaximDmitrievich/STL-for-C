# STL-for-C
Библиотека STL в С++ представляет из себя набор из готовых абрстрактных структур данных. 

В СТЛ по стандарту идут такие структуры как:

Стек

Очередь

Дек

Список

Ассоциативный массив(мап, мультимап)

Приоритетная очередь

Вектор

Множество(мультимножество)


Все эти структуры реализуются с помощью указателей. Необходима работа с динамической памятью. В реализацию самих структур будут подключаться такие загловочники как stdlib.h, string.h, stdbool.h. В некоторых случаях будут еще и задейстованы итераторы. 

Дабы реализовать библиотеку, которая будет отвечать требованиям STL, будем использовать поступающие данные на вход в виде void *, а размер этих данных будет храниться в самой структуре.

##Стек

Стек представляет собой структуру данных, где мы имеем доступ только к элементу, который лежит на верху стопки данных. Мы можем добавлять в начало и удалять с начала структуры. Следуя тому, что все структуры будут реализованы на указателях, будем считать, что все элементы соединены указетелeм next. Над стеком определены операции создания стека, добавления в него нового элемента, просмотра верхнего элемента, удаления элемента, просмотр размера стека, проверка пустоты стека, очистка стека и удаления всего стека. [Реализация стека](Stack/)

##Очередь

Очередь представляет собой структуру данных, где все элементы выстроены друг за другом с помощью указателя next и мы имеем доступ к элементу, который стоит в голове очереди. Добавлять мы можем только в конец очереди. Над очередьью определены такие операции: добавление в конец, просмотор головы очереди, очистка очереди, проверка пустоты очереди, размер очереди, удаление головы очереди(вместо старого элемента встает новый элемент в голову очереди по указателю next) и удаление всей очереди. [Реализация очереди](Queue/)

## Дек

Дек является разновидностью очереди, так как имеет подобную структуру, но при условии, что добавлять и удалять можно с обоих концов очереди. Получается такая двунаправленная очередь. Над деком определены операции вставки в конец и в начало, просмотр конца и начала, удаление элемента из конца и с начала, размер дека, проверка пустоты дека, создание дека, очистка и удаление всего дека. [Реализация дека](Deque/)


## Список

Списки подразумевают под собой набор элементов, выстроенных друг за другом, доступ к которым есть O(1). Все элементы соеденины друг с другом двумя указателями - prev и next. В данном случае получается двунаправленный список, по которому можно ходить туда сюда. Для навигации по списку используются итераторы, которые помогают пользователю проходить список во всех направлениях. Над итераторами определены операции постановка итератора в начало, в конец, удаление итератора, создание итератора, проверка на равенство и неравенство двух итераторов, вставка в начало списка, вставка в конец списка,удаление элемента, получение его значения на данном элементе и задание значения этого элемента(чтобы не перевыделять память для данной позиции под новый элемент просто заменим значение старого элемента на значение нового), переход к следующему элементу и к предыдущему. Над самим списком обозначены операции создания и удаления списка, проверки на пустоту списка, получение размера списка, вставка в начало и в конец, просмотр первого и последнего элемента, удаление первого и последнего, удаление элемента, разворот списка в обратном направлении(конец и начало меняются местами) и очистка списка.  [Реализация списка](List/)

## Ассоциативный массив

Ассоциативный массив - это структура данных, в которой каждый элемент имеет свое значение и ключ, по которому мы будем его искать. Одинаковых элементов существовать не может! По сути в STL мап принято называть словарем, где каждому значению сопоставлен ключ. Возможной реализацией может быть и красно-черное дерево, но более удобной и легкой реализацией можно считать реализацию через таблицы прямого доступа(хеш-таблицы). Плюс такой реализиции в том, что в среднем у нас доступ и поиск будет осуществляться за О(1), но в худшем может быть О(n). В данной реализации используется хеш-функция, называемая DJB функция хеширования, основанная на магическом числе 33. Поскольку, массив имеет переменный размер, хешироваться он будет по значению доступных ячеек, чтобы хеши не выходили за пределы таблицы. Создается таблица под 32 элемента(при заполнении таблицы память будет увеличиваться под нужное кол-во элементов), где ключ хешируется и значение помещается в ячейку, по указанному хешу. Над этой структурой определены операции как создание массива, вставка, получение значения, удаление элемента и удаление всего массива. Мультимап является продолжением ассоциативного массива. Его различие лишь в том, что в нем могут быть соответствия одному ключу нескольких значений. [Реализация ассоциативного массива](Map/)

## Приоритетная очередь 

Приоритетная очередь - еще одна разновидность очередей, где элементы уже заведомо отсортированы по своему приоритету. В такой очереди так же присутствует голова и конец очереди, но первым из очереди выходи элемент с наибольшим приоритетом. Над этой структурой определены такие операции как создание очереди, удаление очереди, очистка очереди, получение размера очереди, вставка, просмотр элемента в голове и удаление элемента. Реализация такой очереди будет основываться на двоичной куче, где элементы с наибольшим значением будут всплывать в нашем двоичном дереве на уровень выше. Плюс этой реализации в том, что почти все функции будут ииметь сложность O(Logn), а пространственная сложность будет О(1).[Реализация приоритетной очереди](Priority queue/)


## Вектор (динамический массив)

Вектор в STL - это динамический массив, который время от времени по надобности изменяет доступный размер. В него можно вписать столько элементов, сколько позволяет память компьютера. Он будет расширяться и сужаться по мере того, как добавляются и удаляются элементы в нем. В векторе так же необходим итератор, который обеспечивает навигацию по вектору. Элементы храняться в массиве, под который будет перевыделяться память функцией realloc. Над вектором определены такие операции, как создание вектора, удаление, перевыделение память под вектор, размер вектора, полнота вектора, получение значения элемента вектора и задание значения элемента вектора, получение и задание значения конца и начала вектора, возвращение значения элемента вектора, вставка в конец и удаление из конца вектора. Итератор здесь имеет примерно похожие функции, как в списке, но для разрешения функций, установленных над самим вектором. Так же над вектором установлена функция сортировки вектора, которая основана на быстрой сортировке Хоара. [Реализация вектора](Vector/)

## Множество и мультимножество

Множеством называют набор некоторых элементов, расположенных упорядоченно по возростанию. Во множестве не может существовать двух или более одинаковых элементов. Отличие множества от мультимножества заключается лишь в том, что в мультимножестве может существовать несколько одинаковых элементов. Множество реализованно на структуре сбалансированного дерева, где по мере добавления все вершины дерева балансируются, дабы создать сложность всей структуры О(Logn). Во множестве определен итератор. Поскольку сама структура является сбалансированным деревом, будем считать, что итератор может ходить влево, вправо и вверх от данного элемента. Это отходит от реализации в C++ и самой STL, но не отменяет полезности этих итераторов. Итератор имеет следующие функции: создание, начало, лево, право, вверх, получить элемент и получить значение элемента. Само множество определяет над собой функции создания, вставки, удаления, пересечения двух множеств, объединения, инверсии, дополнения и удаления множеств. [Реализация множества](Set/)
